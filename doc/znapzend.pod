=head1 NAME

znapzend - znapzend daemon

=head1 SYNOPSIS

B<znapzend> [I<options>...]

 --man                  show man-page and exit
 --version              print version and exit
 -h,--help              display this help and exit
 -d,--debug             print debug messages to STDERR
 -n,--noaction          run in simulation mode: does no changes to the filesystem
 --nodelay              if a backup plan has a zend_delay defined, ignore it
 --nodestroy            does all changes to the filesystem except destroy
 --logto=x              select where to log to (syslog::<facility> or <filepath>)
 --loglevel=x           define the log level
 --pidfile=x            write a pid file when running in daemon mode
 --daemonize            fork into the background
 --runonce=[x]          run one round on the optionally provided dataset
 -r,--recursive         recurse from the given "run-once" dataset
 --inherited            allow "run-once" on dataset which only inherits a plan
 --features=x           comma separated list of features to be enabled
 --rootExec=x           exec zfs with this command to obtain root privileges (sudo or pfexec)
 --connectTimeout=x     sets the ConnectTimeout for ssh commands
 --autoCreation         automatically create dataset on dest if it does not exist
 --timeWarp=x           shift znapzends sens of NOW into the future by x seconds
 --skipOnPreSnapCmdFail skip snapshots if the pre-snap-command fails
 --skipOnPreSendCmdFail skip replication if the pre-send-command fails

=head1 DESCRIPTION

ZnapZend is a snapshot based zfs backup daemon creating snapshots on a
scheduled basis on the source filesystem and on destination filesystems.

ZnapZend reads its configuration from custom properties in the dataset.
Use L<znapzendzetup> to set and list these properties.

=over

=item B<-d>, B<--debug>

talk a lot while running. Sends debug messages to stderr.

=item B<-n>, B<--noaction>

don't do any actions which have lasting effect. Ideal to try out new
configurations together with B<--debug>

=item B<--nodelay>

if a backup plan has a zend_delay defined, ignore it (should help when
debugging the backup plan configurations, without waiting for hours to
run them during experiments)

=item B<--nodestroy>

do all changes to the filesystem except destroying old snapshots

=item B<--logto>={B<syslog::>I<facility>|I<filepath>}

send logs out to either syslog or a logfile. Default is to send logs to
B<syslog::daemon> when runing daemonized. When running in debug mode, the
logs will go to STDERR by default.

Examples:

 --logto=/var/log/znapzend.log
 --logto=syslog::daemon

=item B<--loglevel>={B<debug>|B<info>|B<warning>|B<err>|B<alert>}

Define the log level when logging to file. Default is debug.

=item B<--pidfile>=I<path>

write a pid file when running in daemon mode
B<pidfile> defaults to I</var/run/znapzend.pid> if no pidfile is given

=item B<--daemonize>

Fork into the background.

=item B<--runonce>=[I<dataset>]

run one round on source I<dataset> or on all datasets if empty.
This is very useful for testing. Use it in connection with B<--noaction> and
B<--debug> while testing your new configuration, or with B<--recursive> for
quick back up of whatever has backup plans in a single pool or dataset tree.

=item B<-r>, B<--recursive>

when backing up a particular dataset with B<--runonce>=[I<dataset>], do not
just look at this dataset's backup plan, but iterate into its children that
might have any. Useful for quick backups of a pool whose root dataset has no
I<znapzendzetup> configurations defined, but some trees under it do.

See below for interaction with B<--inherited> option and examples.

=item B<--inherited>

when backing up a particular dataset with B<--runonce>=[I<dataset>], do not
require that the provided dataset directly has a locally defined backup plan
configuration (sanity check that it is not "received" via ZFS replication).
With this option in place, allow also to quickly snapshot and/or replicate
datasets of subtrees which inherit a backup plan from a dataset which has it
in its attributes whose source is "local".

=item B<--inherited> and B<--recursive> together

At this time, the B<--inherited> is "sort of exclusive" vs. B<--recursive>
mode, and if both are specified the behavior depends on whether the requested
dataset has some (local or inherited-from-local) backup plan. If a dataset
without a backup plan is passed, the script should effectively ignore the
B<--inherited> option and just recurse until it finds some dataset(s) with
proper locally defined backup plan(s) (note that finding inherited plans
first is highly unlikely due to ZFS attribute inheritance from parents to
children).

Examples below assume the following dataset layout:

+ I<tank> (no znapzend config)
| + I<export> (local znapzend config)
| | + I<home> (inherited znapzend config from local tank/export)
| |   + I<user> (inherited znapzend config from local tank/export)
| |     + I<sources> (inherited znapzend config from local tank/export)
| |     + I<documents> (inherited znapzend config from local tank/export)
| |       + I<pictures> (inherited znapzend config from local tank/export)
| + I<var> (local znapzend config)
+ I<usbbackup> (no znapzend config)
  + I<snapshots> (no znapzend config)
    + I<export> (received znapzend config)
    | + I<home> (inherited from received usbbackup/snapshots/export)
    |   + I<user> (inherited from received usbbackup/snapshots/export)
    |     + I<sources> (inherited from received usbbackup/snapshots/export)
    |     + I<documents> (inherited from received usbbackup/snapshots/export)
    |       + I<documents> (inherited from received usbbackup/snapshots/export)
    + I<var> (received znapzend config)

Examples:

  znapzend --recursive --runonce=tank

This should walk all filesystem or volume datasets defined anywhere under
I<tank> (root dataset of same-named pool) and snapshot/replicate the found
datasets that have a backup plan configured "locally", such as I<tank/export>
and I<tank/var>, according to configuration (e.g. with children and beyond
if the corresponding backup plan's I<recursive=on> option is specified).
It should not waste time looking for datasets under the I<usbbackup> pool.

  znapzend --runonce=tank/export/home/user/documents

Given that only I<tank/export> "locally" defines a znapzend backup plan, the
default B<znapzend> behavior with a descendant dataset would be to find no
configuration (sourced as "local" right in it) and so would "run-once" nothing.

  znapzend --recursive --runonce=tank/export/home

Same (no config found) for recursion starting from a dataset with inherited
backup plan configuration (assuming none of its descendants have a "local"
config of their own).

  znapzend --inherited --runonce=tank/export/home/user/documents

With the B<--inherited> option however it would recognize this descendant
dataset as having a backup plan configuration inherited from I<tank/export>,
would then look at I<tank/export> and confirm that it has this configuration
from a "local" source, and should B<znapzend runonce> just this dataset and
its descendants (so including I<tank/export/home/user/documents/pictures>,
but not including siblings like I<tank/export/home/user/sources>).

  znapzend --inherited --recursive --runonce=tank

Since I<tank> has no backup plan, B<znapzend> should recurse and find the
nearest datasets with configured plans, I<tank/export> and I<tank/var>, and
process them according to configuration.

  znapzend --inherited --recursive --runonce=tank/export

Since I<tank/export> has a locally defined backup plan, B<znapzend> should
process it according to configuration.

  znapzend --inherited --recursive --runonce=tank/export/home

Since I<tank/export/home> has a backup plan inherited from a locally defined
one in I<tank/export>, B<znapzend> should process it according to configuration.

  znapzend --recursive --runonce=usbbackup
  znapzend --inherited --runonce=usbbackup/snapshots
  znapzend --inherited --recursive --runonce=usbbackup/snapshots/export/home

Neither of these runs should do anything, because all datasets involved
(including those found by a recursive walk) under I<usbbackup> have neither
a local definition of a backup plan, nor one inherited from a local definition.


=item B<--features>=I<feature1>,I<feature2>,...

enables enhanced zfs features not supported by all zfs implementations.
Do not enable features unless you are sure your zfs supports (or requires) it

Available features:

=over

=item oracleMode

working around the following zfs issues we have seen on oracle:

=over

=item *

The multi snapshot destroy syntax is not available. So stick to destroying
them individually.

=item *

Sometimes a snapshot can not be destroyed because of some oracle zfs bug.
Only a reeboot seems to be able to fix this. So we just destroy the ones we
can destroy. Logging an error about the problem

=back

=item recvu

use the -u option on the receive end, to keep the destination zfs
filesystems unmounted.

=item compressed

use 'compressed' to add options -Lce to the zfs send command

Even if a source and destination datasets are both using compression,
zfs send will, by default, decompress the data before sending, and
zfs recv will then compress it again before writing it to disk.
Using -c will skip the unnecessary decompress-compress stages.
This decreases CPU load on both source and destination as well
as reduces network bandwidth usage.

The -L option is for large block support and -e is for embedded data
support. These may require certain (Open)ZFS features to be enabled.

=item lowmemRecurse

use 'lowmemRecurse' on systems where you have too many datasets,
so a recursive listing of attributes to find backup plans exhausts
the memory available to `znapzend(zetup)`: instead, go the slower
way to first list all impacted dataset names, and then query their
configs one by one.

=item zfsGetType

use 'zfsGetType' if your 'zfs get' supports a '-t' argument for
filtering by dataset type at all (e.g. one in Solaris 10 does not),
AND lists properties for snapshots by default when recursing (e.g.
the one in Solaris 10u8 already does), so that there is too much
data to process while searching for backup plans.

If these two conditions apply to your system, the time needed for
a '--recursive' search for backup plans can literally differ by
hundreds of times (depending on the amount of snapshots in that
dataset tree... and a decent backup plan will ensure you have a
lot of those), so you would benefit from requesting this feature.

This feature should not impact the default (non- '--recursive')
listings however.

=back

=item B<--rootExec>={sudo|pfexec}

Execute zfs with this command, 'sudo' or 'pfexec', to
obtain root privileges. This is often necessary when running znapzend as a
non-privileged user with a zfs install that doesn't support finer permission
controls. This also applies to the zfs commands ran on remote servers over ssh.

For sudo, the /etc/sudoers file will need to be modified to allow for
passwordless access to zfs commands if znapzend is to be ran as a daemon or
the system will be used as a remote. Many ZFS installations include an
/etc/sudoers.d/zfs file as an example.

=item B<--connectTimeout>=I<timeout>

sets the ssh connection timeout (in seconds)

=item B<--autoCreation>

Automatically create a dataset on a destination host if it's not there yet.

=item B<--timeWarp>=x

Shift ZnapZends sense of time into the future by x seconds.

The practical application if this function is to determine what will happen
at some future point in time. This can be useful for testing but also when
running in B<noaction> and B<debug> mode to determine which snapshots would
be created and removed at some future point in time.

=item B<--skipOnPreSnapCmdFail>

Prevent snapshots of a dataset from being taken when it has a B<pre-snap-command>
defined and the command returns a non-zero exit code or is killed by a signal.

=item B<--skipOnPreSendCmdFail>

Prevent snapshots of a dataset from being replicated to a destination when
it has a B<pre-snap-command> defined and the command returns a non-zero exit
code or is killed by a signal.

=back

=head1 EXAMPLE

To test a new config:

 znapzend --debug --noaction --runonce=tank/test

To see what is going to happen in one hour:

 znapzend --debug --noaction --timeWarp=3600 --runonce=tank/test

To run as a daemon:

 znapzend --daemonize --pidfile=/var/run/znapzend.pid --logto=syslog::daemon

=head1 COPYRIGHT

Copyright (c) 2014 by OETIKER+PARTNER AG. All rights reserved.

=head1 LICENSE

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see L<http://www.gnu.org/licenses/>.

=head1 AUTHOR

S<Tobias Oetiker E<lt>tobi@oetiker.chE<gt>>,
S<Dominik Hassler E<lt>hadfl@cpan.orgE<gt>>

=head1 HISTORY

 2014-06-01 had Multi destination backup
 2014-05-30 had Initial Version

=cut
